#!/usr/bin/env python

# Copyright (C) 2015 Mark Schouten <mark@tuxis.nl>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2 dated June,
# 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# See http://www.gnu.org/licenses/gpl.txt for the full license

from subprocess import check_output
import json

# Retrives infomation about the ceph cluster using the "ceph status" command.
# Collected stats include current cluster health, osd counts including total number of osd, up and in osds,
# the number of placement groups, ceph storage capacity and total capacity used.
def cephstatus():
    cephstatus = check_output(["/usr/bin/ceph", "-f", "json", "status"]).replace('-inf', '0')
    s = json.loads(cephstatus)

    try:
        health = s['health']['overall_status']
    except:
        health = "UNKNOWN"
    try:
        num_osds = s['osdmap']['osdmap']['num_osds']
    except:
        num_osds = 0
    try:
        num_up_osds = s['osdmap']['osdmap']['num_up_osds']
    except:
        num_up_osds = 0
    try:
        num_in_osds = s['osdmap']['osdmap']['num_in_osds']
    except:
        num_in_osds = 0
    try:
        num_remapped_pgs = s['osdmap']['osdmap']['num_remapped_pgs']
    except:
        num_remapped_pgs = 0
    try:
        nearfull = int(s['osdmap']['osdmap']['nearfull'] == 'true')
    except:
        nearfull = 0
    try:
        full = int(s['osdmap']['osdmap']['full'] == 'true')
    except:
        full = 0

    print("health:%s" % (health))
    print("num_osds:%i" % (num_osds))
    print("num_up_osds:%i" % (num_up_osds))
    print("num_in_osds:%i" % (num_in_osds))
    print("num_remapped_pgs:%i" % (num_remapped_pgs))
    print("nearfull:%i" % (nearfull))
    print("full:%i" % (full))

    try:
        num_pgs = s['pgmap']['num_pgs']
    except:
        num_pgs = 0
    try:
        num_pools = s['pgmap']['num_pools']
    except:
        num_pools = 0
    try:
        num_objects = s['pgmap']['num_objects']
    except:
        num_objects = 0
    try:
        data_bytes = s['pgmap']['data_bytes']
    except:
        data_bytes = 0
    try:
        bytes_used = s['pgmap']['bytes_used']
    except:
        bytes_used = 0
    try:
        bytes_avail = s['pgmap']['bytes_avail']
    except:
        bytes_avail = 0
    try:
        bytes_total = s['pgmap']['bytes_total']
    except:
        bytes_total = 0
    try:
        read_bytes_sec = s['pgmap']['read_bytes_sec']
    except:
        read_bytes_sec = 0
    try:
        write_bytes_sec = s['pgmap']['write_bytes_sec']
    except:
        write_bytes_sec = 0
    try:
        read_op_per_sec = s['pgmap']['read_op_per_sec']
    except:
        read_op_per_sec = 0
    try:
        write_op_per_sec = s['pgmap']['write_op_per_sec']
    except:
        write_op_per_sec = 0

    print("num_pgs:%i" % (num_pgs))
    print("num_pools:%i" % (num_pools))
    print("num_objects:%i" % (num_objects))
    print("data_bytes:%i" % (data_bytes))
    print("bytes_used:%i" % (bytes_used))
    print("bytes_avail:%i" % (bytes_avail))
    print("bytes_total:%i" % (bytes_total))
    print("read_bytes_sec:%i" % (read_bytes_sec))
    print("write_bytes_sec:%i" % (write_bytes_sec))
    print("read_op_per_sec:%i" % (read_op_per_sec))
    print("write_op_per_sec:%i" % (write_op_per_sec))

    # All the possible states for placement groups. Placement groups may have more than one state simultaneouly.
    # List of placement group states reference http://docs.ceph.com/docs/mimic/rados/operations/pg-states/
    states = {"creating": 0, "activating": 0, "active": 0, "clean": 0, "down": 0, "scrubbing": 0,
              "deep": 0, "degraded": 0, "inconsistent": 0, "peering": 0, "repair": 0, "recovering": 0,
              "recovering": 0, "forced_recovery": 0, "recovery_wait": 0, "recovery_toofull": 0,
              "recovery_unfound": 0, "backfilling": 0, "forced_backfill": 0, "backfill_wait": 0,
              "backfill_toofull": 0, "backfill_unfound": 0, "incomplete": 0, "stale": 0, "remapped": 0,
              "undersized": 0, "peered": 0, "snaptrim": 0, "snaptrim_wait": 0, "snaptrim_error": 0}

    # Updates the states dictionary with the count of placement groups in each state. 
    # A placement group can have multiple states such as "active+clean", this means the placement group
    # is both in the state active and clean. For each possible state count the number of pgs in that state.
    # Example of pgs states output.
    # 1067 active+clean
    # 66   active+undersized+degraded+remapped+backfill_wait
    # 3    active+undersized+degraded+remapped+backfilling
    # In the above example the states dictionary would be updated with 
    # 1136 active, 1067 clean, 69 undersized, 69 degraded, 69 remapped, 66 backfill_wait, 3 backfilling and all
    # other states remaining at 0.
    for pg_state_gp in s['pgmap']['pgs_by_state']:
        gp_states = pg_state_gp['state_name'].split("+")
        for pgst in gp_states:
            states[pgst] += pg_state_gp['count']

    # print out all placement group state counts.
    print "<pgstates>"
    for state in states:
        print("pgstate.%s:%i" % (state, states[state]))


def cephdf():
    cephdf    = check_output(["/usr/bin/ceph", "-f", "json", "df"]).replace('-inf', '0')

    s = json.loads(cephdf)
    try:
        ts = s['stats']['total_bytes']
    except:
        ts = s['stats']['total_space']
    try:
        tu = s['stats']['total_used_bytes']
    except:
        tu = s['stats']['total_used']
    try:
        ta = s['stats']['total_avail_bytes']
    except:
        ta = s['stats']['total_avail']

    print("c:%i:%i:%i" % (ts, tu, ta))

    for p in s['pools']:
        b = p['stats']['bytes_used']
        a = p['stats']['max_avail']
        o = p['stats']['objects']
        print("%s:%i:%i:%i" % (p['name'], a, b, o))


def osdperf():
    osdperf   = check_output(["/usr/bin/ceph", "-f", "json", "osd", "perf"]).replace('-inf', '0')

    for o in json.loads(osdperf)['osd_perf_infos']:
        print("osd.%s:%i:%i" % (o['id'], o['perf_stats']['apply_latency_ms'], o['perf_stats']['commit_latency_ms']))

def poolstats():
    poolstats = check_output(["/usr/bin/ceph", "-f", "json", "osd", "pool", "stats"]).replace('-inf', '0')

    for p in json.loads(poolstats):
        try: 
            r = p['client_io_rate']['read_bytes_sec']
        except:
            r = 0
        try: 
            w = p['client_io_rate']['write_bytes_sec']
        except:
            w = 0
        try: 
            o = p['client_io_rate']['op_per_sec']
        except:
            o = 0
    
        print("%s:%i:%i:%i" % (p['pool_name'], o, w, r))

print "<<<app-ceph>>>"
print "<cephstatus>"
cephstatus()
print "<poolstats>"
poolstats()
print "<osdperformance>"
osdperf()
print "<df>"
cephdf()
